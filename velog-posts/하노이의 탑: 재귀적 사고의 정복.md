<p>🗼하노이의 탑은 재귀(Recursion)의 원리를 가장 잘 보여주는 대표적인 문제입니다. 처음에는 매우 복잡하고 막막하게 느껴지지만, '재귀적 사고'의 핵심을 이해하면 의외로 간단한 규칙을 발견할 수 있습니다.</p>
<h2 id="📜1-문제-정의">📜1. 문제 정의</h2>
<p>세 개의 기둥(A, B, C)이 있고, 첫 번째 기둥(A)에 크기가 다른 N개의 원반이 쌓여 있습니다. 아래 규칙을 지키면서 모든 원반을 A에서 C기둥으로 옮겨야 합니다.</p>
<blockquote>
<p><strong>규칙</strong></p>
<ol>
<li>한 번에 하나의 원반만 옮길 수 있다.</li>
<li>크기가 큰 원반은 크기가 작은 원반 위에 쌓을 수 없다.</li>
</ol>
</blockquote>
<h2 id="2-재귀적-사고-과정-가장-큰-놈-하나만-해결하자">2. 재귀적 사고 과정: &quot;가장 큰 놈 하나만 해결하자&quot;</h2>
<p>이 문제의 핵심은 N개의 원반을 한 번에 옮기려고 생각하는 것이 아니라, <strong>&quot;가장 큰 N번째 원반 하나를 목적지로 옮기려면 어떻게 해야 할까?&quot;</strong> 라는 질문에서 시작하는 것입니다.</p>
<p><strong>최종 목표:</strong> <strong>N</strong>개의 원반을 A에서 C로 옮긴다.
<img alt="" src="https://velog.velcdn.com/images/csj0209/post/0440bc60-c99b-44f0-ab61-d9da5cd8c83c/image.png" /></p>
<ol>
<li><strong>문제를 단순화</strong>: <code>N-1</code>개의 작은 원반들이 없다면, 가장 큰 N번째 원반을 A에서 C로 옮기는 것은 한 번이면 끝납니다. 그렇다면, 방해가 되는 <code>N-1</code>개의 원반들을 <strong>중간 기둥 B</strong>로 잠시 치워둘 수 있다면 어떨까요?<ul>
<li><strong>1단계: N-1개의 원반을 A에서 B로 옮긴다.</strong>(위 그림의 3에 해당)</li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>가장 큰 문제 해결</strong>: 이제 A기둥에는 N번째 원반 하나만 남았습니다. 이것을 C기둥으로 옮깁니다. (이동 횟수: 1회)<ul>
<li><strong>2단계: N번째 원반을 A에서 C로 옮긴다.</strong>(위 그림의 4에 해당)</li>
</ul>
</li>
</ol>
<ol start="3">
<li><strong>남은 문제 해결</strong>: 마지막으로, 중간 기둥 B에 옮겨두었던 <code>N-1</code>개의 원반을 다시 C기둥 위로 옮기면 모든 과정이 끝납니다.<ul>
<li><strong>3단계: N-1개의 원반을 B에서 C로 옮긴다.</strong>(위 그림의 7에 해당)</li>
</ul>
</li>
</ol>
<p>위 과정을 보면, &quot;N개의 원반을 옮기는 문제&quot;가 &quot;N-1개의 원반을 옮기는 문제&quot; 두 개와 1번의 이동으로 축소되었습니다. 이것이 바로 하노이의 탑의 재귀 구조입니다.</p>
<h2 id="3-🔢점화식과-일반항-도출">3. 🔢점화식과 일반항 도출</h2>
<p>위 사고 과정을 그대로 수학적 점화식으로 옮길 수 있습니다.</p>
<ul>
<li><code>N</code>개의 원반을 옮기는 횟수 <code>H(N)</code> = <code>N-1</code>개를 A에서 B로 옮기는 횟수 (<code>H(N-1)</code>) + 가장 큰 원반 하나를 A에서 C로 옮기는 횟수 (<code>1</code>) + <code>N-1</code>개를 B에서 C로 옮기는 횟수 (<code>H(N-1)</code>)</li>
</ul>
<p>이를 정리하면 <strong><code>H(N) = 2 * H(N-1) + 1</code></strong> 이라는 점화식이 탄생합니다.
이 점화식을 풀면 <strong><code>H(N) = 2^N - 1</code></strong> 이라는 일반항을 얻을 수 있습니다.(by 계차수열)
<img alt="" src="https://velog.velcdn.com/images/csj0209/post/0666d901-7b40-45ab-a9bc-b7f6bbd18fd0/image.png" /></p>
<h2 id="💻4-코드-구현">💻4. 코드 구현</h2>
<p>위 재귀 구조를 코드로 그대로 옮기면 다음과 같습니다.</p>
<pre><code class="language-java">public class TowerOfHanoi {

    /**
     * 하노이의 탑 재귀 함수
     * @param n 원반의 개수
     * @param start 시작 기둥
     * @param via 중간 기둥
     * @param target 목표 기둥
     */
    public static void hanoi(int n, String start, String target, String via) {
        // base case
        if (n == 1) {
            System.out.println(&quot;1번 원반을 &quot; + start + &quot;에서 &quot; + target + &quot;로 이동&quot;);
            return;
        }

        hanoi(n - 1, start, via, target);
        System.out.println(n + &quot;번 원반을 &quot; + start + &quot;에서 &quot; + target + &quot;로 이동&quot;);
        hanoi(n - 1, via, target, start);
    }
}</code></pre>
<hr />
<p>📚참고자료
🔗&quot;하노이의 탑&quot; 이해하기: <a href="https://shoark7.github.io/programming/algorithm/tower-of-hanoi">https://shoark7.github.io/programming/algorithm/tower-of-hanoi</a></p>