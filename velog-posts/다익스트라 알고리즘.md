<p>π“Άλ³Έ ν¬μ¤νΈλ” BFSμ™€ λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ λΉ„κµν•κ³ , μλ°” μ–Έμ–΄λ΅ λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ λΉ„κµν•λ” λ‚΄μ©μ΄λΌ 
λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ μμ„Έν• κ³Όμ •μ΄ κ¶κΈν•λ©΄ <a href="https://velog.io/@csj0209/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦(νμ΄μ¬ λ²„μ „)</a>μ„ μ°Έκ³ ν•μ‹κΈ° λ°”λλ‹λ‹¤.</p>
<h1 id="π“bfs-μ•κ³ λ¦¬μ¦">π“BFS μ•κ³ λ¦¬μ¦</h1>
<p>λ¨Όμ € λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ μ‚΄ν΄λ³΄κΈ° μ „μ—, κ°€μ¤‘μΉκ°€ μ—†λ” BFS μ•κ³ λ¦¬μ¦μ νλ¦„μ„ μ‚΄ν΄λ³΄μ.</p>
<ol>
<li><p>μ‚¬μ „μ„Έν…: visited λ°°μ—΄κ³Ό ν(FIFOκµ¬μ΅°, μΈμ ‘ λ…Έλ“ νƒμƒ‰μ©)λ΅ μ‹μ‘ μ •μ μ„ μ‚½μ…ν•λ‹¤.</p>
</li>
<li><p>νκ°€ λΉ λ•κΉμ§€: νλ¥Ό dequeueν•΄μ„ ν„μ¬ λ…Έλ“λ΅ μ„¤μ •ν•κ³ , forλ¬ΈμΌλ΅ μΈμ ‘ λ…Έλ“λ¥Ό νƒμƒ‰ν•λ‹¤.</p>
</li>
<li><ol>
<li>λ§μ•½ μΈμ ‘ λ…Έλ“λ¥Ό λ°©λ¬Έν•μ§€ μ•μ•μΌλ©΄ -&gt; λ°©λ¬Έμ— μ¶”κ°€ &amp;&amp; νλ΅ λ°©λ¬Έ μμ•½</li>
</ol>
</li>
<li><p>νκ°€ λΉ„μ—μΌλ©΄(BFS νƒμƒ‰μ„ μ™„λ£ν–μΌλ©΄) visitedλ¥Ό λ¦¬ν„΄</p>
</li>
</ol>
<h2 id="π“λ‹¤μµμ¤νΈλΌ-μ•κ³ λ¦¬μ¦">π“λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦</h2>
<p>μ΄ μ•κ³ λ¦¬μ¦μ€ μ„μ BFS μ•κ³ λ¦¬μ¦κ³Ό λΉ„μ·ν•λ°, λ‹¨μ§€ <strong>κ°„μ„ μ— λΉ„μ©</strong>μ΄ μλ‹¤λ” κ²ƒκ³Ό, <strong>λΉ„μ©μ„ μ°μ„ μμ„</strong>λ΅ ν•΄μ„ <strong>ν„μ¬κΉμ§€ μ•λ ¤μ§„ λ…Έλ“μ λΉ„μ©κ³Ό λΉ„κµ</strong>ν•λ©΄μ„ μµμ† λΉ„μ©μ„ μ—…λ°μ΄νΈν•λ‹¤λ” κ²ƒμ΄λ‹¤.</p>
<ol>
<li><p>μ‚¬μ „μ„Έν…: <strong>dist 1μ°¨μ› λ°°μ—΄</strong>, μ°μ„ μμ„ ν μ΄κΈ°ν™”</p>
</li>
<li><ol>
<li>distλ¥Ό <strong>λ¨λ‘ λ¬΄ν•λ€</strong>λ΅ μ„¤μ •(μ•„μ§ κ²½λ΅λ¥Ό νƒμƒ‰ν•μ§€ μ•μ•λ‹¤λ” μλ―Έ)</li>
</ol>
</li>
<li><ol start="2">
<li>μ‹μ‘ μ •μ μ„ <code>dist[start] = 0</code>μΌλ΅ μ‚½μ…ν•κ³ , μ°μ„ μμ„ νμ—λ„ μ‚½μ…ν•λ‹¤.
π’΅λΉ„μ©μ„ μ°μ„ μμ„λ΅ λ‘κΈ° μ„ν•΄μ„λ”, 
<del><code>implements Comparable&lt;NodeCost&gt;</code>λ΅ μΈν„°νμ΄μ¤λ¥Ό κ°•μ λ΅ κµ¬ν„ν•΄μ•Ό ν•κ³ , 
<code>public int compareTo(NodeCost other) { return Integer.compare(this.cost, o.cost);</code>λ¥Ό μ¤λ²„λΌμ΄λ”© ν•΄μ•Ό ν•λ‹¤.</del>
<code>PriorityQueue&lt;NodeCost&gt; pq = new PriorityQueue&lt;&gt;((node1, node2) -&gt; Integer.compare(node1.cost, node2.cost));</code>μ™€ κ°™μ΄ λλ‹¤μ‹μ„ ν™μ©ν•λ©΄ μ»¤μ¤ν…€ ν΄λμ¤μ—μ„ Comparable μΈν„°νμ΄μ¤λ¥Ό κ°•μ  κµ¬ν„ν•μ§€ μ•μ•„λ„ λλ‹¤.</li>
</ol>
</li>
<li><p>νκ°€ λΉ λ•κΉμ§€: νλ¥Ό dequeueν•΄μ„ ν„μ¬ λ…Έλ“μ™€ ν„μ¬ λΉ„μ©μΌλ΅ μ„¤μ •ν•κ³ , <code>if(curCost &gt; dist[curNode])</code>λ΅ <strong>BFSλ¥Ό ν†µν•΄ μ°μ„ μμ„ νμ— μ¶”κ°€λ μΈμ ‘λ…Έλ“μ λΉ„μ©μ΄ ν„μ¬κΉμ§€ μ•λ ¤μ§„ λ…Έλ“μ λΉ„μ©λ³΄λ‹¤ ν¬λ©΄</strong> <code>continue</code>λ΅ μ•„λμ μΈμ ‘ λ…Έλ“ νƒμƒ‰ κ³Όμ •μ„ <strong>μ¤ν‚µ</strong>ν•λ‹¤.</p>
</li>
<li><ol>
<li>forλ¬ΈμΌλ΅ μΈμ ‘ λ…Έλ“λ¥Ό νƒμƒ‰</li>
</ol>
</li>
<li><ol start="2">
<li>μΌλ‹¨ μΈμ ‘ λ…Έλ“μ λΉ„μ©μ„ ν„μ¬ λΉ„μ© + μΈμ ‘ λ…Έλ“μ λΉ„μ©μΌλ΅ μ—…λ°μ΄νΈν•λ‹¤.</li>
</ol>
</li>
<li><ol start="3">
<li>λ§μ•½ μΈμ ‘ λ…Έλ“μ λΉ„μ©μ΄ κΈ°μ΅΄μ— μ•λ ¤μ§„ ν•΄λ‹Ή μΈμ ‘ λ…Έλ“κΉμ§€μ μµλ‹¨ κ²½λ΅ λΉ„μ©λ³΄λ‹¤ μ μΌλ©΄ -&gt; distμ— μ¶”κ°€ &amp;&amp; μ°μ„ μμ„ νλ΅ λ°©λ¬Έ μμ•½
π‘‰μ΄ κ³Όμ •μ΄ BFSμ μ¤‘λ³µ λ°©λ¬Έ μ²΄ν¬λ¥Ό λ„μ–΄μ„ &quot;λ” μ§§μ€ λΉ„μ© μμΌλ©΄ μ—…λ°μ΄νΈ&quot; κ³Όμ •μ„ λ™μ‹μ— μ¶©μ΅±ν•λ‹¤.</li>
</ol>
</li>
<li><p>μ°μ„ μμ„ νκ°€ λΉ„μ—μΌλ©΄ <code>dist[end]</code>λ΅ λ§μ§€λ§‰ λ…Έλ“μ λΉ„μ©μ„ λ¦¬ν„΄
π‘‰μ΄λ•, <code>return dist[end] == Integer.MAX_VALUE ? -1 : dist[end];</code>λ΅ λ§μ§€λ§‰ λ…Έλ“κΉμ§€ νƒμƒ‰ μ—¬λ¶€λ¥Ό μ• μ μλ‹¤.</p>
</li>
</ol>
<h3 id="π’»λ‹¤μµμ¤νΈλΌ">π’»λ‹¤μµμ¤νΈλΌ</h3>
<pre><code class="language-java">package src.heap;

import java.util.*;

public class Dijkstra {
    public int dijkstra(List&lt;List&lt;NodeCost&gt;&gt; graph, int start, int end) {
        // μµλ‹¨ κ±°λ¦¬ μ €μ¥ λ°°μ—΄
        // 1μ°¨μ› λ°°μ—΄(index: node, value: cost)
        int[] dist = new int[graph.size()];
        Arrays.fill(dist, Integer.MAX_VALUE); // νƒμƒ‰ν•μ§€ μ•μ€ κ°’μ„ λ¬΄ν•λ€λ΅ μ΄κΈ°ν™”
        PriorityQueue&lt;NodeCost&gt; pq = new PriorityQueue&lt;&gt;((node1, node2) -&gt; Integer.compare(node1.cost, node2.cost));
        // μ‚¬μ „ μ„Έν…
        dist[start] = 0;
        pq.offer(new NodeCost(start, 0));

        while (!pq.isEmpty()) {
            NodeCost cur = pq.poll();
            int curNode = cur.node;
            int curCost = cur.cost;

            // μ°μ„ μμ„ νμ— μ¶”κ°€λ μΈμ ‘λ…Έλ“ λΉ„μ©μ΄ ν„μ¬κΉμ§€ μ•λ ¤μ§„ λ…Έλ“μ λΉ„μ©λ³΄λ‹¤ ν¬λ©΄ μ•„λμ κ³Όμ •μ„ μ¤ν‚µ
            if (curCost &gt; dist[curNode]) continue;

            // μΈμ ‘ λ…Έλ“ νƒμƒ‰
            for (NodeCost nextNode : graph.get(curNode)) {
                // μΌλ‹¨ λΉ„μ© μ—…λ°μ΄νΈ
                int nextCost = curCost + nextNode.cost;

                // λ” μ§§μ€ λΉ„μ©μ΄ μλ”μ§€ μ²΄ν¬
                if (nextCost &lt; dist[nextNode.node]) {
                    // λ°©λ¬Έ + μμ•½
                    dist[nextNode.node] = nextCost;
                    pq.offer(new NodeCost(nextNode.node, nextCost));
                }

            }
        }

        // λ§μ§€λ§‰ λ…Έλ“μ λΉ„μ©μ„ λ¦¬ν„΄
        return dist[end] == Integer.MAX_VALUE ? -1 : dist[end];

    }

    private static class NodeCost {
        int node;
        int cost;

        public NodeCost(int node, int cost) {
            this.node = node;
            this.cost = cost;

        }

    }

}</code></pre>
<ul>
<li>λ§μ•½ λ¬Έμ μ—μ„ 1~Nλ² κΉμ§€μ λ…Έλ“κ°€ μ£Όμ–΄μ΅μΌλ©΄, distμ ν¬κΈ°λ¥Ό <code>graph.size() + 1</code>λ΅ μ΄κΈ°ν™”ν•΄μ¤μ•Ό ν•λ‹¤.<ul>
<li>0λ² μΈλ±μ¤λ” μ‚¬μ©ν•μ§€ μ•κΈ° λ•λ¬Έ</li>
</ul>
</li>
</ul>
<hr />
<p>π“μ°Έκ³ μλ£
μ°μ„ μμ„ νμ μ λ„¤λ¦­ νƒ€μ…μ„ μ»¤μ¤ν…€ ν΄λμ¤λ΅ λ§λ“λ” λ°©λ²•: <a href="https://velog.io/@gillog/Java-Priority-Queue%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%90#priority-queue-using-costom-class">https://velog.io/@gillog/Java-Priority-Queue%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%90#priority-queue-using-costom-class</a></p>