<p>📢핵심만 간추리기 위해 모든 소스코드는 아래에서 보실 수 있습니다👇
<a href="https://github.com/Seung-zedd/Real-World-Software-Development-Study/tree/main/OOP/src/main/java/com/real_software/chapter_02">chapter_2 소스코드</a></p>
<h1 id="🚩도전-과제">🚩도전 과제</h1>
<p>🤔마크 버그저커: 흐음... 내가 수시로 은행에 직접 가서 매달 입출금 내역을 받는 것도 번거로운데, <strong>입출금 내역을 자동으로 분석해 재정 상태를 더 잘보여주는 소프트웨어</strong>를 개발해줄 개발자 어디 없나?</p>
<p>👨‍💻그 요구사항을 들은 나의 반응:
<img alt="" src="https://velog.velcdn.com/images/csj0209/post/b031d0e2-dbf3-4c04-a283-3d21ee4334ff/image.jpg" /></p>
<h1 id="🏁목표">🏁목표</h1>
<ul>
<li>단일 책임 원칙(Single Responsibility Principle): 쉽게 유지보수하고, 이해할 수 있으며 버그가 발생하는 범위를 줄이는데 도움을 줌</li>
<li>응집도(Cohesion)와 결합도(Coupling): 개발하는 코드와 소프트웨어의 품질을 유지하는데 유용</li>
</ul>
<h1 id="📜입출금-내역-분석기-요구-사항">📜입출금 내역 분석기 요구 사항</h1>
<p>마크는 온라인 인터넷 뱅킹 사이트에서 자신의 거래 내역 파일을 내려받았으며, 이 텍스트 파일은 콤마로 분리된 값인 CSV 형식으로 구성되어 있다. 은행 거래 내역 예시는 다음과 같다.</p>
<pre><code class="language-csv">30-01-2017,-100,Deliveroo
30-01-2017,-50,Tesco
01-02-2017,6000,Salary

...(생략)</code></pre>
<p>마크는 이것도 모자라서 개발자에게 다음과 같은 문제들의 답을 원한다:</p>
<ul>
<li>❓은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가?</li>
<li>❓특정 달엔 몇 건의 입출금 내역이 발생했는가?</li>
<li>❓지출이 가장 높은 상위 10건은 무엇인가?</li>
<li>❓돈을 가장 많이 소비하는 항목은 무엇인가?</li>
</ul>
<h2 id="💋kisskeep-it-short-and-simple-원칙">💋KISS(Keep It Short and Simple) 원칙</h2>
<p>응용프로그램 코드를 <strong>한 개의 클래스</strong>로 구현</p>
<ul>
<li>아직은 파일이 존재하지 않거나 파일 내용을 파싱할 때 발생하는 문제를 해결하기 위한 예외 처리에 신경 쓸 필요 x 
👉_예외 처리_는 3장에서 설명</li>
</ul>
<p>💊KISS 원칙을 남용하면 <strong><span style="color: red;">갓 클래스 안티 패턴</span></strong>이 발생하므로 주의할 것!</p>
<h3 id="final-변수">final 변수</h3>
<p>자바 언어에서 final을 선언하면 이 변수에 값을 재할당할 수 없다.</p>
<ul>
<li>final로 선언하면 객체의 상태 변화 유무를 표시할 수 있다고 함</li>
<li>그러나, final 필드로 가리키는 객체라도 가변 상태(mutable state)를 포함하기 때문에 불변성을 유지할 수 있는 것은 아니다.
👉4장에서 _불변성(immutability)_에 대해 자세히 설명</li>
</ul>
<p>😣인터페이스(추상 메서드)에 final로 선언해봤자 껍데기만 있는 메서드이기 때문에 별 효력 x
👉예제5-15에서 살펴볼껀데, 자바10부터 <em>var</em> 키워드가 등장하면서 final 유용성 감소</p>
<h2 id="코드-유지보수성과-안티-패턴">코드 유지보수성과 안티 패턴</h2>
<p>기존의 코드를 복붙해서 새로운 요구 사항들을 해결하면 다음과 같은 문제가 생김:</p>
<ul>
<li>한 개의 거대한 _갓 클래스(god class)_때문에 코드를 이해하기 어려움</li>
<li><em>코드 중복</em> 때문에 코드가 불안정하고 변화에 쉽게 망가짐</li>
</ul>
<p>😈이러한 패턴들을 안티패턴(anti-pattern)이라고 부름</p>
<h3 id="갓-클래스god-class">갓 클래스(god class)</h3>
<p>한 개의 파일에 모든 코드를 때려박아서 결국 하나의 거대한 클래스가 탄생 -&gt; 관심사의 분리가 없어서 <span style="color: red;">클래스 목적 파악 어려움</span>
🔨이후의 단일 책임 원칙(SRP)가 이 안티 패턴을 해결</p>
<h3 id="코드-중복">코드 중복</h3>
<p>🤔만약에 CSV파일 대신 JSON같은 다른 파일들로 입력 형식이 바뀐다면 어떻게 될까? 기존의 코드는 CSV파일만 적용되기 때문에 하드 코딩된 코드들을 전부 뜯어고쳐야 할 것이다.</p>
<ul>
<li>또한, 새로운 열을 추가하거나 속성명이 다른 다양한 데이터 형식을 지원하려면 기존의 코드는 무용지물이 된다.
🔖DRY(Don't Repeat Yourself): 반복을 제거하면 로직을 바꿔도 코드 변경 가능성이 낮아짐</li>
</ul>
<h2 id="단일-책임-원칙srp">단일 책임 원칙(SRP)</h2>
<p>SRP는 &quot;한 클래스는 한 기능만 책임진다&quot;와 &quot;클래스가 바뀌어야 하는 이유는 오직 하나(의 책임)여야 한다.&quot;라는 클래스의 목적을 보완하기 위해 설립된 원칙이다.</p>
<p>이전의 예제2-2에서는 파일 읽기 및 파싱, 결과 처리 및 결과 표시를 하나의 클래스에 모두 구현했는데 만약에 이 갓 클래스에서 클래스 변경 이유가 2가지 이상이면 코드를 부분 수정해야 하기 때문에 유지보수 비용이 증가한다.
👉따라서, 아래와 같은 책임들을 별개의 클래스로 분리해야 한다:</p>
<ol>
<li>입력 읽기</li>
<li>주어진 형식의 입력 파싱</li>
<li>결과 처리</li>
<li>결과 요약 리포트</li>
</ol>
<p>💡현재 챕터에서는 <strong>파싱과 관련된 기능에 집중</strong>하기 때문에 위에서 서술한 책임들이 몇가지 겹칠 수가 있다. 완벽한 모듈화는 3장에서 진행하기 때문에 일단 SRP가 어떻게 적용되는지에 초점을 맞춰보자.</p>
<h3 id="😯놀람-최소화-원칙principle-of-least-surprise">😯놀람 최소화 원칙(Principle of least surprise)</h3>
<ul>
<li>메서드가 수행하는 일을 바로 이해할 수 있도록 <strong>자체 문서화를 제공하는 메서드명을 사용</strong>한다<ul>
<li><code>caculateTotalAmount()</code>와 같은 메서드명처럼 직관적이여야됨(주로 verb+ N 형태)</li>
</ul>
</li>
<li>코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 <strong>파라미터의 상태를 바꾸지 않는다.</strong></li>
</ul>
<h2 id="응집도cohesion">응집도(Cohesion)</h2>
<p><strong>코드 유지보수성</strong>을 결정하는 중요한 개념으로, <strong>클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지</strong>를 측정하는 지표다.</p>
<ul>
<li>높은 응집도와 코드 가독성 및 이해도, 쉬운 사용성을 위한 것들은 개발자의 목표!</li>
</ul>
<h3 id="클래스-수준-응집도">클래스 수준 응집도</h3>
<p>실무에서는 다음과 같은 6가지 방법으로 그룹화한다.</p>
<ul>
<li>기능, 정보, 유틸리티, 논리, 순차, 시간</li>
</ul>
<table>
<thead>
<tr>
<th>응집도 수준</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>기능(높은 응집도): <strong>기능이 비슷한 메서드</strong>를 그룹화</td>
<td>이해하기 쉬움</td>
<td>너무 단순한 클래스 생성</td>
</tr>
<tr>
<td>정보(중간 응집도): <strong>같은 데이터나 도메인 객체</strong>를 처리하는 메서드를 그룹화</td>
<td>유지보수하기 쉬움</td>
<td>불필요한 디펜던시</td>
</tr>
<tr>
<td>순차(중간 응집도): 입출력 데이터가 서로 관련이 있는 메서드로 그룹화</td>
<td>관련 동작을 찾기 쉬움</td>
<td>SRP를 위배할 수 있음</td>
</tr>
<tr>
<td>논리(중간 응집도): '파싱'이라는 특정 논리적 요소로 그룹화</td>
<td>높은 수준의 카테고리화 제공</td>
<td>SRP를 위배할 수 있음</td>
</tr>
<tr>
<td>유틸리티(낮은 응집도): 관련성이 없는 메서드를 그룹화<span style="color: red;">(권장 X!)</span></td>
<td>간단히 추가 가능</td>
<td>클래스의 책임을 파악하기 어려움</td>
</tr>
<tr>
<td>시간(낮은 응집도): 초기화 작업 및 DB 커넥션 연결 및 종료 관련 메서드</td>
<td>판단 불가</td>
<td>각 동작을 이해하고 사용하기 어려움</td>
</tr>
<tr>
<td>☝사실 위의 응집도 명칭 및 수준을 구현을 할때마다 측정하는 것은 어려운 일이니, 최대한 응집도를 높이는 수준으로 코딩을 하면 될 것이다.</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="메서드-수준-응집도">메서드 수준 응집도</h3>
<p>메서드가 다양한 기능을 수행할수록 메서드의 동작 의도가 불분명해지기 때문에 클래스 및 메서드에 대한 책임도 테스트하기가 어려움 -&gt; 응집도가 높은 <strong>더 작은 조각으로 메서드를 분리</strong>해야함</p>
<h2 id="결합도coupling">결합도(Coupling)</h2>
<p>결합도: 코드가 서로 어떻게 의존하는지와 관련이 있는 척도로, 즉 <strong>어떤 클래스를 구현하는 데 얼마나 많은 지식(다른 클래스)을 참조했는지의 정도</strong>를 나타냄</p>
<ul>
<li>어떤 클래스가 더 많은 클래스들을 참조했다면 기능을 변경할 때 의존성이 높기 때문에 유연성이 떨어지고 코드 유지보수 비용이 높아짐</li>
<li>BankStatementAnalyzer의 경우 필드에서 BankStatementCSVParser 클래스에 의존하기 때문에 JSON 항목 파일로 기능을 변경한다면 필드 자체도 리팩토링 해야함</li>
</ul>
<p>🔨<strong>인터페이스</strong>로 커플링을 낮추면서 유연성을 낮출 수 있으니 번거로운 코드 리팩토링 작업을 거치지 않아도 된다.</p>
<h2 id="테스트">테스트</h2>
<p>고객의 요구사항을 제대로 충족했는지 확인하기 위한 용도로, 자바 테스트 프레임워크로 가장 많이 사용되는 JUnit을 이용해 자동화된 첫번째 테스트를 구현한다.</p>
<h3 id="테스트-자동화">테스트 자동화</h3>
<p>👍코드를 바꿨을 때, 지정된 테스트가 빠르게 실행되므로 <strong>소프트웨어가 예상하지 못한 문제를 일으키지 않고 제대로 동작할 거라는 확신</strong>을 조금 더 가질 수 있음</p>
<h4 id="테스트-자동화의-장점">테스트 자동화의 장점</h4>
<ol>
<li>고객의 요구 사항을 충족하고 있다는 확신</li>
<li>바꾼 코드 변화에도 튼튼함 유지</li>
<li>다양한 컴포넌트의 디펜던시와 이들의 상호작용 파악을 통한 프로그램 이해도 상승</li>
</ol>
<h3 id="테스트-메서드-정의하기">테스트 메서드 정의하기</h3>
<p><code>@Test</code>: 테스트 메서드에 추가함으로써 <strong>유닛 테스트의 실행 대상</strong>임을 지정</p>
<p>유닛 테스트 설정의 세 단계 패턴</p>
<ol>
<li>Given: 테스트 컨텍스트를 설정(주로 테스트 데이터를 넣음)</li>
<li>When: 테스트 대상 메서드를 호출하여 실제 결과를 생성하는 부분</li>
<li>Then: 실제 결과와 예상 결과(expected 객체)를 비교하여 검증하는 부분으로, Assertions 라이브러리를 사용해서 <code>AssertEquals(expected, actual)</code>로 예상되는 결과와 일치한지 비교하는 것도 이 부분에 해당한다.</li>
</ol>
<h3 id="코드-커버리지">코드 커버리지</h3>
<p>테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트했는가를 가리키는 척도</p>
<ul>
<li>70~90%를 목표로 정할 것을 권장</li>
</ul>